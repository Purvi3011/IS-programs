# -*- coding: utf-8 -*-
"""merkle roo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14w5eYTaQu8ZRfubzjkdTu0EkHsCEPA3S

## **IMPLEMENTING MERKLE TREE USING SHA/MD5 ALGORITHM**
"""

import hashlib

L = '''A cryptographic hash is a function that outputs a fixed-size digest for a variable-length input.
A hash function is an important cryptographic primitive and extensively used in blockchain.
For example, SHA-256 is a hash function in which for any variable-bit length input, the output is always going to be a 256-bit hash.'''

file = open("readme.txt","w")
file.writelines(L)
file.close()

"""**FUNCTION TO CHECK WHETHER NUMBER N IS A POWER OF 2**"""

def isPowerOfTwo(n):
    # IF n IS 0, RETURN FALSE
    if (n == 0):
        return False

    while (n != 1):
        # IF n IS NOT DIVISIBLE BY 2, RETURN FALSE
        if (n % 2 != 0):
            return False
        n = n // 2

    return True

"""**FUNCTION TO CREATE A MERKLE TREE**"""

def MerkleTree(PT):
    PT_list = []
    for char in PT:
        # APPENDING ALL CHARS OF INPUT TO PT_list
        PT_list.append(char)
    
    # SINCE INPUT FOR HASHING WILL BE OF 16 BITS,
    # DIVIDING THE PT_list INTO BLOCKS OF 16
    PT_list = [PT_list[i:i+16] for i in range(0, len(PT_list), 16)]

    # TO MAKE LAST BLOCK OF 16 BITS, IF ITS NOT
    if len(PT_list[-1]) < 16:

        diff = 16 - len(PT_list[-1])
        # APPENDING diff 0s TO LAST BLOCKS
        for i in range(diff):
            PT_list[-1].append('0')
    
    # IF LENGTH OF PT_list IS NOT POWER OF 2
    if not isPowerOfTwo(len(PT_list)):
        k = 0
        i = 0
        # CALCULATING NEXT POWER OF 2 > len(PT_list)
        while k < len(PT_list):
            k = 2**i
            i = i+1

        # TAKING THE DIFFERENCE TO MAKE IT POWER OF 2
        diff -= len(PT_list)
        empt = ['0']*16  # PADDING BLOCK TO ADD

        # APPENDING PADDING BLOCK TO PT_list FOR diff TIMES
        for i in range(0, diff):
            PT_list.append(empt)

    print("\nLEVEL 1")
    for i in range(0, len(PT_list)):
        # JOINING OUR SUB-LIST TO MAKE AN TEXT FOR HASHING
        PT_list[i] = ''.join(PT_list[i])

        # CONVERTING SUB-LIST TO utf-8 AND HASHING IT USING MD5
        PT_list[i] = hashlib.md5(PT_list[i].encode("utf-8")).hexdigest()
        print(f"H({i})", PT_list[i])            

    j = 2
    while len(PT_list) != 1:  
        # LOOP TILL WE GET THE MERKLE ROOT OF THE TREE
        print("\n\nLEVEL", j)

        # JOINING HEX STRING IN ORDER OF (1,2), (3,4), ...
        PT_list = [''.join(x[0]+x[1]) for x in zip(PT_list[0::2], PT_list[1::2])]

        # CONVERTING SUB-LIST TO utf-8 AND HASHING IT USING MD5
        for i in range(0, len(PT_list)):
            PT_list[i] = hashlib.md5(PT_list[i].encode("utf-8")).hexdigest()
            print(f"H({i})", PT_list[i])

        j = j + 1

    return PT_list[0]

PT = open('readme.txt').read()
merkleRoot = MerkleTree(PT)

print("\nTHE MERKLE ROOT OR FINAL HASH OF PT IS:", merkleRoot)

